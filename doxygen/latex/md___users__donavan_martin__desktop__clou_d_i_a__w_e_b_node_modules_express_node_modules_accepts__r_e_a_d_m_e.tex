\href{https://npmjs.org/package/accepts}{\tt !\mbox{[}N\+P\+M Version\mbox{]}\mbox{[}npm-\/image\mbox{]}} \href{https://npmjs.org/package/accepts}{\tt !\mbox{[}N\+P\+M Downloads\mbox{]}\mbox{[}downloads-\/image\mbox{]}} \href{http://nodejs.org/download/}{\tt !\mbox{[}Node.\+js Version\mbox{]}\mbox{[}node-\/version-\/image\mbox{]}} \href{https://travis-ci.org/jshttp/accepts}{\tt !\mbox{[}Build Status\mbox{]}\mbox{[}travis-\/image\mbox{]}} \href{https://coveralls.io/r/jshttp/accepts}{\tt !\mbox{[}Test Coverage\mbox{]}\mbox{[}coveralls-\/image\mbox{]}}

Higher level content negotiation based on \href{https://www.npmjs.com/package/negotiator}{\tt negotiator}. Extracted from \href{https://www.npmjs.com/package/koa}{\tt koa} for general use.

In addition to negotiator, it allows\+:


\begin{DoxyItemize}
\item Allows types as an array or arguments list, ie `(\mbox{[}\textquotesingle{}text/html\textquotesingle{}, \textquotesingle{}application/json\textquotesingle{}\mbox{]}){\ttfamily as well as}(\textquotesingle{}text/html\textquotesingle{}, \textquotesingle{}application/json\textquotesingle{}){\ttfamily .}
\item {\ttfamily Allows type shorthands such as}json{\ttfamily .}
\item {\ttfamily Returns}false{\ttfamily when no types match}
\item {\ttfamily Treats non-\/existent headers as}$\ast$`
\end{DoxyItemize}

\subsection*{Installation}


\begin{DoxyCode}
1 npm install accepts
\end{DoxyCode}


\subsection*{A\+P\+I}


\begin{DoxyCode}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} accepts = require(\textcolor{stringliteral}{'accepts'})
\end{DoxyCode}


\subsubsection*{accepts(req)}

Create a new {\ttfamily Accepts} object for the given {\ttfamily req}.

\paragraph*{.charset(charsets)}

Return the first accepted charset. If nothing in {\ttfamily charsets} is accepted, then {\ttfamily false} is returned.

\paragraph*{.charsets()}

Return the charsets that the request accepts, in the order of the client\textquotesingle{}s preference (most preferred first).

\paragraph*{.encoding(encodings)}

Return the first accepted encoding. If nothing in {\ttfamily encodings} is accepted, then {\ttfamily false} is returned.

\paragraph*{.encodings()}

Return the encodings that the request accepts, in the order of the client\textquotesingle{}s preference (most preferred first).

\paragraph*{.language(languages)}

Return the first accepted language. If nothing in {\ttfamily languages} is accepted, then {\ttfamily false} is returned.

\paragraph*{.languages()}

Return the languages that the request accepts, in the order of the client\textquotesingle{}s preference (most preferred first).

\paragraph*{.type(types)}

Return the first accepted type (and it is returned as the same text as what appears in the {\ttfamily types} array). If nothing in {\ttfamily types} is accepted, then {\ttfamily false} is returned.

The {\ttfamily types} array can contain full M\+I\+M\+E types or file extensions. Any value that is not a full M\+I\+M\+E types is passed to `require(\textquotesingle{}mime-\/types\textquotesingle{}).lookup`.

\paragraph*{.types()}

Return the types that the request accepts, in the order of the client\textquotesingle{}s preference (most preferred first).

\subsection*{Examples}

\subsubsection*{Simple type negotiation}

This simple example shows how to use {\ttfamily accepts} to return a different typed respond body based on what the client wants to accept. The server lists it\textquotesingle{}s preferences in order and will get back the best match between the client and server.


\begin{DoxyCode}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} accepts = require(\textcolor{stringliteral}{'accepts'})
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} http = require('http')

\hyperlink{class_test_a51a683fa4fcec142ab1574e00a7b6860}{function} app(req, res) \{
  \hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} accept = accepts(req)

  \textcolor{comment}{// the order of this list is significant; should be server preferred order}
  \hyperlink{ce__parse_8cpp_ada8aa24d50028bab4e2a4437e6eb7807}{switch}(accept.type(['json', 'html'])) \{
    \textcolor{keywordflow}{case} \textcolor{stringliteral}{'json'}:
      res.setHeader(\textcolor{stringliteral}{'Content-Type'}, \textcolor{stringliteral}{'application/json'})
      res.write(\textcolor{stringliteral}{'\{"hello":"world!"\}'})
      \textcolor{keywordflow}{break}
    \textcolor{keywordflow}{case} \textcolor{stringliteral}{'html'}:
      res.setHeader(\textcolor{stringliteral}{'Content-Type'}, \textcolor{stringliteral}{'text/html'})
      res.write(\textcolor{stringliteral}{'<b>hello, world!</b>'})
      \textcolor{keywordflow}{break}
    \textcolor{keywordflow}{default}:
      \textcolor{comment}{// the fallback is text/plain, so no need to specify it above}
      res.setHeader(\textcolor{stringliteral}{'Content-Type'}, \textcolor{stringliteral}{'text/plain'})
      res.write(\textcolor{stringliteral}{'hello, world!'})
      \textcolor{keywordflow}{break}
  \}

  res.end()
\}

http.createServer(app).listen(3000)
\end{DoxyCode}


You can test this out with the c\+U\+R\+L program\+: 
\begin{DoxyCode}
1 curl -I -H'Accept: text/html' http://localhost:3000/
\end{DoxyCode}


\subsection*{License}

\mbox{[}M\+I\+T\mbox{]}(L\+I\+C\+E\+N\+S\+E) 