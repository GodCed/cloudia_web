\href{https://npmjs.org/package/body-parser}{\tt !\mbox{[}N\+P\+M Version\mbox{]}\mbox{[}npm-\/image\mbox{]}} \href{https://npmjs.org/package/body-parser}{\tt !\mbox{[}N\+P\+M Downloads\mbox{]}\mbox{[}downloads-\/image\mbox{]}} \href{https://travis-ci.org/expressjs/body-parser}{\tt !\mbox{[}Build Status\mbox{]}\mbox{[}travis-\/image\mbox{]}} \href{https://coveralls.io/r/expressjs/body-parser?branch=master}{\tt !\mbox{[}Test Coverage\mbox{]}\mbox{[}coveralls-\/image\mbox{]}} \href{https://www.gratipay.com/dougwilson/}{\tt !\mbox{[}Gratipay\mbox{]}\mbox{[}gratipay-\/image\mbox{]}}

Node.\+js body parsing middleware.

{\itshape This does not handle multipart bodies}, due to their complex and typically large nature. For multipart bodies, you may be interested in the following modules\+:


\begin{DoxyItemize}
\item \href{https://www.npmjs.org/package/busboy#readme}{\tt busboy} and \href{https://www.npmjs.org/package/connect-busboy#readme}{\tt connect-\/busboy}
\item \href{https://www.npmjs.org/package/multiparty#readme}{\tt multiparty} and \href{https://www.npmjs.org/package/connect-multiparty#readme}{\tt connect-\/multiparty}
\item \href{https://www.npmjs.org/package/formidable#readme}{\tt formidable}
\item \href{https://www.npmjs.org/package/multer#readme}{\tt multer}
\end{DoxyItemize}

This module provides the following parsers\+:


\begin{DoxyItemize}
\item \href{#bodyparserjsonoptions}{\tt J\+S\+O\+N body parser}
\item \href{#bodyparserrawoptions}{\tt Raw body parser}
\item \href{#bodyparsertextoptions}{\tt Text body parser}
\item \href{#bodyparserurlencodedoptions}{\tt U\+R\+L-\/encoded form body parser}
\end{DoxyItemize}

Other body parsers you might be interested in\+:


\begin{DoxyItemize}
\item \href{https://www.npmjs.org/package/body#readme}{\tt body}
\item \href{https://www.npmjs.org/package/co-body#readme}{\tt co-\/body}
\end{DoxyItemize}

\subsection*{Installation}


\begin{DoxyCode}
1 $ npm install body-parser
\end{DoxyCode}


\subsection*{A\+P\+I}


\begin{DoxyCode}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} bodyParser = require(\textcolor{stringliteral}{'body-parser'})
\end{DoxyCode}


The {\ttfamily body\+Parser} object exposes various factories to create middlewares. All middlewares will populate the {\ttfamily req.\+body} property with the parsed body or provide an error to the callback. The various errors are described in the \href{#errors}{\tt errors section}.

\subsubsection*{body\+Parser.\+json(options)}

Returns middleware that only parses {\ttfamily json}. This parser accepts any Unicode encoding of the body and supports automatic inflation of {\ttfamily gzip} and {\ttfamily deflate} encodings.

\hyperlink{class_a}{A} new {\ttfamily body} object containing the parsed data is populated on the {\ttfamily request} object after the middleware (i.\+e. {\ttfamily req.\+body}).

\paragraph*{Options}

The {\ttfamily json} function takes an option {\ttfamily options} object that may contain any of the following keys\+:

\subparagraph*{inflate}

When set to {\ttfamily true}, then deflated (compressed) bodies will be inflated; when {\ttfamily false}, deflated bodies are rejected. Defaults to {\ttfamily true}.

\subparagraph*{limit}

Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the \href{https://www.npmjs.com/package/bytes}{\tt bytes} library for parsing. Defaults to {\ttfamily \textquotesingle{}100kb\textquotesingle{}}.

\subparagraph*{reviver}

The {\ttfamily reviver} option is passed directly to {\ttfamily J\+S\+O\+N.\+parse} as the second argument. You can find more information on this argument \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter}{\tt in the M\+D\+N documentation about J\+S\+O\+N.\+parse}.

\subparagraph*{strict}

When set to {\ttfamily true}, will only accept arrays and objects; when {\ttfamily false} will accept anything {\ttfamily J\+S\+O\+N.\+parse} accepts. Defaults to {\ttfamily true}.

\subparagraph*{type}

The {\ttfamily type} option is used to determine what media type the middleware will parse. This option can be a function or a string. If a string, {\ttfamily type} option is passed directly to the \href{https://www.npmjs.org/package/type-is#readme}{\tt type-\/is} library and this can be an extension name (like {\ttfamily json}), a mime type (like {\ttfamily application/json}), or a mime time with a wildcard (like {\ttfamily $\ast$/$\ast$} or {\ttfamily $\ast$/json}). If a function, the {\ttfamily type} option is called as {\ttfamily fn(req)} and the request is parsed if it returns a truthy value. Defaults to {\ttfamily json}.

\subparagraph*{verify}

The {\ttfamily verify} option, if supplied, is called as {\ttfamily verify(req, res, buf, encoding)}, where {\ttfamily buf} is a {\ttfamily Buffer} of the raw request body and {\ttfamily encoding} is the encoding of the request. The parsing can be aborted by throwing an error.

\subsubsection*{body\+Parser.\+raw(options)}

Returns middleware that parses all bodies as a {\ttfamily Buffer}. This parser supports automatic inflation of {\ttfamily gzip} and {\ttfamily deflate} encodings.

\hyperlink{class_a}{A} new {\ttfamily body} object containing the parsed data is populated on the {\ttfamily request} object after the middleware (i.\+e. {\ttfamily req.\+body}). This will be a {\ttfamily Buffer} object of the body.

\paragraph*{Options}

The {\ttfamily raw} function takes an option {\ttfamily options} object that may contain any of the following keys\+:

\subparagraph*{inflate}

When set to {\ttfamily true}, then deflated (compressed) bodies will be inflated; when {\ttfamily false}, deflated bodies are rejected. Defaults to {\ttfamily true}.

\subparagraph*{limit}

Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the \href{https://www.npmjs.com/package/bytes}{\tt bytes} library for parsing. Defaults to {\ttfamily \textquotesingle{}100kb\textquotesingle{}}.

\subparagraph*{type}

The {\ttfamily type} option is used to determine what media type the middleware will parse. This option can be a function or a string. If a string, {\ttfamily type} option is passed directly to the \href{https://www.npmjs.org/package/type-is#readme}{\tt type-\/is} library and this can be an extension name (like {\ttfamily bin}), a mime type (like {\ttfamily application/octet-\/stream}), or a mime time with a wildcard (like {\ttfamily $\ast$/$\ast$} or {\ttfamily application/$\ast$}). If a function, the {\ttfamily type} option is called as {\ttfamily fn(req)} and the request is parsed if it returns a truthy value. Defaults to {\ttfamily application/octet-\/stream}.

\subparagraph*{verify}

The {\ttfamily verify} option, if supplied, is called as {\ttfamily verify(req, res, buf, encoding)}, where {\ttfamily buf} is a {\ttfamily Buffer} of the raw request body and {\ttfamily encoding} is the encoding of the request. The parsing can be aborted by throwing an error.

\subsubsection*{body\+Parser.\+text(options)}

Returns middleware that parses all bodies as a string. This parser supports automatic inflation of {\ttfamily gzip} and {\ttfamily deflate} encodings.

\hyperlink{class_a}{A} new {\ttfamily body} string containing the parsed data is populated on the {\ttfamily request} object after the middleware (i.\+e. {\ttfamily req.\+body}). This will be a string of the body.

\paragraph*{Options}

The {\ttfamily text} function takes an option {\ttfamily options} object that may contain any of the following keys\+:

\subparagraph*{default\+Charset}

Specify the default character set for the text content if the charset is not specified in the {\ttfamily Content-\/\+Type} header of the request. Defaults to {\ttfamily utf-\/8}.

\subparagraph*{inflate}

When set to {\ttfamily true}, then deflated (compressed) bodies will be inflated; when {\ttfamily false}, deflated bodies are rejected. Defaults to {\ttfamily true}.

\subparagraph*{limit}

Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the \href{https://www.npmjs.com/package/bytes}{\tt bytes} library for parsing. Defaults to {\ttfamily \textquotesingle{}100kb\textquotesingle{}}.

\subparagraph*{type}

The {\ttfamily type} option is used to determine what media type the middleware will parse. This option can be a function or a string. If a string, {\ttfamily type} option is passed directly to the \href{https://www.npmjs.org/package/type-is#readme}{\tt type-\/is} library and this can be an extension name (like {\ttfamily txt}), a mime type (like {\ttfamily text/plain}), or a mime time with a wildcard (like {\ttfamily $\ast$/$\ast$} or {\ttfamily text/$\ast$}). If a function, the {\ttfamily type} option is called as {\ttfamily fn(req)} and the request is parsed if it returns a truthy value. Defaults to {\ttfamily text/plain}.

\subparagraph*{verify}

The {\ttfamily verify} option, if supplied, is called as {\ttfamily verify(req, res, buf, encoding)}, where {\ttfamily buf} is a {\ttfamily Buffer} of the raw request body and {\ttfamily encoding} is the encoding of the request. The parsing can be aborted by throwing an error.

\subsubsection*{body\+Parser.\+urlencoded(options)}

Returns middleware that only parses {\ttfamily urlencoded} bodies. This parser accepts only U\+T\+F-\/8 encoding of the body and supports automatic inflation of {\ttfamily gzip} and {\ttfamily deflate} encodings.

\hyperlink{class_a}{A} new {\ttfamily body} object containing the parsed data is populated on the {\ttfamily request} object after the middleware (i.\+e. {\ttfamily req.\+body}). This object will contain key-\/value pairs, where the value can be a string or array (when {\ttfamily extended} is {\ttfamily false}), or any type (when {\ttfamily extended} is {\ttfamily true}).

\paragraph*{Options}

The {\ttfamily urlencoded} function takes an option {\ttfamily options} object that may contain any of the following keys\+:

\subparagraph*{extended}

The {\ttfamily extended} option allows to choose between parsing the U\+R\+L-\/encoded data with the {\ttfamily querystring} library (when {\ttfamily false}) or the {\ttfamily qs} library (when {\ttfamily true}). The \char`\"{}extended\char`\"{} syntax allows for rich objects and arrays to be encoded into the U\+R\+L-\/encoded format, allowing for a J\+S\+O\+N-\/like experience with U\+R\+L-\/encoded. For more information, please \href{https://www.npmjs.org/package/qs#readme}{\tt see the qs library}.

Defaults to {\ttfamily true}, but using the default has been deprecated. Please research into the difference between {\ttfamily qs} and {\ttfamily querystring} and choose the appropriate setting.

\subparagraph*{inflate}

When set to {\ttfamily true}, then deflated (compressed) bodies will be inflated; when {\ttfamily false}, deflated bodies are rejected. Defaults to {\ttfamily true}.

\subparagraph*{limit}

Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the \href{https://www.npmjs.com/package/bytes}{\tt bytes} library for parsing. Defaults to {\ttfamily \textquotesingle{}100kb\textquotesingle{}}.

\subparagraph*{parameter\+Limit}

The {\ttfamily parameter\+Limit} option controls the maximum number of parameters that are allowed in the U\+R\+L-\/encoded data. If a request contains more parameters than this value, a 413 will be returned to the client. Defaults to {\ttfamily 1000}.

\subparagraph*{type}

The {\ttfamily type} option is used to determine what media type the middleware will parse. This option can be a function or a string. If a string, {\ttfamily type} option is passed directly to the \href{https://www.npmjs.org/package/type-is#readme}{\tt type-\/is} library and this can be an extension name (like {\ttfamily urlencoded}), a mime type (like {\ttfamily application/x-\/www-\/form-\/urlencoded}), or a mime time with a wildcard (like {\ttfamily $\ast$/x-\/www-\/form-\/urlencoded}). If a function, the {\ttfamily type} option is called as {\ttfamily fn(req)} and the request is parsed if it returns a truthy value. Defaults to {\ttfamily urlencoded}.

\subparagraph*{verify}

The {\ttfamily verify} option, if supplied, is called as {\ttfamily verify(req, res, buf, encoding)}, where {\ttfamily buf} is a {\ttfamily Buffer} of the raw request body and {\ttfamily encoding} is the encoding of the request. The parsing can be aborted by throwing an error.

\subsection*{Errors}

The middlewares provided by this module create errors depending on the error condition during parsing. The errors will typically have a {\ttfamily status} property that contains the suggested H\+T\+T\+P response code.

The following are the common errors emitted, though any error can come through for various reasons.

\subsubsection*{content encoding unsupported}

This error will occur when the request had a {\ttfamily Content-\/\+Encoding} header that contained an encoding but the \char`\"{}inflation\char`\"{} option was set to {\ttfamily false}. The {\ttfamily status} property is set to {\ttfamily 415}.

\subsubsection*{request aborted}

This error will occur when the request is aborted by the client before reading the body has finished. The {\ttfamily received} property will be set to the number of bytes received before the request was aborted and the {\ttfamily expected} property is set to the number of expected bytes. The {\ttfamily status} property is set to {\ttfamily 400}.

\subsubsection*{request entity too large}

This error will occur when the request body\textquotesingle{}s size is larger than the \char`\"{}limit\char`\"{} option. The {\ttfamily limit} property will be set to the byte limit and the {\ttfamily length} property will be set to the request body\textquotesingle{}s length. The {\ttfamily status} property is set to {\ttfamily 413}.

\subsubsection*{request size did not match content length}

This error will occur when the request\textquotesingle{}s length did not match the length from the {\ttfamily Content-\/\+Lentgh} header. This typically occurs when the requst is malformed, typically when the {\ttfamily Content-\/\+Length} header was calculated based on characters instead of bytes. The {\ttfamily status} property is set to {\ttfamily 400}.

\subsubsection*{stream encoding should not be set}

This error will occur when something called the {\ttfamily req.\+set\+Encoding} method prior to this middleware. This module operates directly on bytes only and you cannot call {\ttfamily req.\+set\+Encoding} when using this module. The {\ttfamily status} property is set to {\ttfamily 500}.

\subsubsection*{unsupported charset \char`\"{}\+B\+O\+G\+U\+S\char`\"{}}

This error will occur when the request had a charset parameter in the {\ttfamily Content-\/\+Type} header, but the {\ttfamily iconv-\/lite} module does not support it O\+R the parser does not support it. The charset is contained in the message as well as in the {\ttfamily charset} property. The {\ttfamily status} property is set to {\ttfamily 415}.

\subsubsection*{unsupported content encoding \char`\"{}bogus\char`\"{}}

This error will occur when the request had a {\ttfamily Content-\/\+Encoding} header that contained an unsupported encoding. The encoding is contained in the message as well as in the {\ttfamily encoding} property. The {\ttfamily status} property is set to {\ttfamily 415}.

\subsection*{Examples}

\subsubsection*{express/connect top-\/level generic}

This example demonstrates adding a generic J\+S\+O\+N and U\+R\+L-\/encoded parser as a top-\/level middleware, which will parse the bodies of all incoming requests. This is the simplest setup.


\begin{DoxyCode}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} express = require(\textcolor{stringliteral}{'express'})
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} bodyParser = require('body-parser')

\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} app = express()

\textcolor{comment}{// parse application/x-www-form-urlencoded}
app.use(bodyParser.urlencoded(\{ extended: \textcolor{keyword}{false} \}))

\textcolor{comment}{// parse application/json}
app.use(bodyParser.json())

app.use(\hyperlink{class_test_a51a683fa4fcec142ab1574e00a7b6860}{function} (req, res) \{
  res.setHeader(\textcolor{stringliteral}{'Content-Type'}, \textcolor{stringliteral}{'text/plain'})
  res.write(\textcolor{stringliteral}{'you posted:\(\backslash\)n'})
  res.end(JSON.stringify(req.body, null, 2))
\})
\end{DoxyCode}


\subsubsection*{express route-\/specific}

This example demonstrates adding body parsers specifically to the routes that need them. In general, this is the most recommend way to use body-\/parser with express.


\begin{DoxyCode}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} express = require(\textcolor{stringliteral}{'express'})
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} bodyParser = require('body-parser')

\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} app = express()

\textcolor{comment}{// create application/json parser}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} jsonParser = bodyParser.json()

\textcolor{comment}{// create application/x-www-form-urlencoded parser}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} urlencodedParser = bodyParser.urlencoded(\{ extended: \textcolor{keyword}{false} \})

\textcolor{comment}{// POST /login gets urlencoded bodies}
app.post(\textcolor{stringliteral}{'/login'}, urlencodedParser, \hyperlink{class_test_a51a683fa4fcec142ab1574e00a7b6860}{function} (req, res) \{
  \textcolor{keywordflow}{if} (!req.body) \textcolor{keywordflow}{return} res.sendStatus(400)
  res.send(\textcolor{stringliteral}{'welcome, '} + req.body.username)
\})

\textcolor{comment}{// POST /api/users gets JSON bodies}
app.post(\textcolor{stringliteral}{'/api/users'}, jsonParser, \hyperlink{class_test_a51a683fa4fcec142ab1574e00a7b6860}{function} (req, res) \{
  \textcolor{keywordflow}{if} (!req.body) \textcolor{keywordflow}{return} res.sendStatus(400)
  \textcolor{comment}{// create user in req.body}
\})
\end{DoxyCode}


\subsubsection*{change content-\/type for parsers}

All the parsers accept a {\ttfamily type} option which allows you to change the {\ttfamily Content-\/\+Type} that the middleware will parse.


\begin{DoxyCode}
\textcolor{comment}{// parse various different custom JSON types as JSON}
app.use(bodyParser.json(\{ type: \textcolor{stringliteral}{'application/*+json'} \}))

\textcolor{comment}{// parse some custom thing into a Buffer}
app.use(bodyParser.raw(\{ type: \textcolor{stringliteral}{'application/vnd.custom-type'} \}))

\textcolor{comment}{// parse an HTML body into a string}
app.use(bodyParser.text(\{ type: \textcolor{stringliteral}{'text/html'} \}))
\end{DoxyCode}


\subsection*{License}

\mbox{[}M\+I\+T\mbox{]}(L\+I\+C\+E\+N\+S\+E) 