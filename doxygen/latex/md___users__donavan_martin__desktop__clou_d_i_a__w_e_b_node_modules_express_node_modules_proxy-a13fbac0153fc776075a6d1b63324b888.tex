ipaddr.\+js is a small (1.\+9\+K minified and gzipped) library for manipulating I\+P addresses in Java\+Script environments. It runs on both Common\+J\+S runtimes (e.\+g. \href{http://nodejs.org}{\tt nodejs}) and in a web browser.

ipaddr.\+js allows you to verify and parse string representation of an I\+P address, match it against a C\+I\+D\+R range or range list, determine if it falls into some reserved ranges (examples include loopback and private ranges), and convert between I\+Pv4 and I\+Pv4-\/mapped I\+Pv6 addresses.

\subsection*{Installation}

{\ttfamily npm install ipaddr.\+js}

\subsection*{A\+P\+I}

ipaddr.\+js defines one object in the global scope\+: {\ttfamily ipaddr}. In Common\+J\+S, it is exported from the module\+:


\begin{DoxyCode}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} ipaddr = require(\textcolor{stringliteral}{'ipaddr.js'});
\end{DoxyCode}


The A\+P\+I consists of several global methods and two classes\+: ipaddr.\+I\+Pv6 and ipaddr.\+I\+Pv4.

\subsubsection*{Global methods}

There are three global methods defined\+: {\ttfamily ipaddr.\+is\+Valid}, {\ttfamily ipaddr.\+parse} and {\ttfamily ipaddr.\+process}. All of them receive a string as a single parameter.

The {\ttfamily ipaddr.\+is\+Valid} method returns {\ttfamily true} if the address is a valid I\+Pv4 or I\+Pv6 address, and {\ttfamily false} otherwise. It does not throw any exceptions.

The {\ttfamily ipaddr.\+parse} method returns an object representing the I\+P address, or throws an {\ttfamily Error} if the passed string is not a valid representation of an I\+P address.

The {\ttfamily ipaddr.\+process} method works just like the {\ttfamily ipaddr.\+parse} one, but it automatically converts I\+Pv4-\/mapped I\+Pv6 addresses to their I\+Pv4 couterparts before returning. It is useful when you have a Node.\+js instance listening on an I\+Pv6 socket, and the {\ttfamily net.\+ivp6.\+bindv6only} sysctl parameter (or its equivalent on non-\/\+Linux O\+S) is set to 0. In this case, you can accept I\+Pv4 connections on your I\+Pv6-\/only socket, but the remote address will be mangled. Use {\ttfamily ipaddr.\+process} method to automatically demangle it.

\subsubsection*{\hyperlink{struct_object}{Object} representation}

Parsing methods return an object which descends from {\ttfamily ipaddr.\+I\+Pv6} or {\ttfamily ipaddr.\+I\+Pv4}. These objects share some properties, but most of them differ.

\paragraph*{Shared properties}

One can determine the type of address by calling {\ttfamily addr.\+kind()}. It will return either {\ttfamily \char`\"{}ipv6\char`\"{}} or {\ttfamily \char`\"{}ipv4\char`\"{}}.

An address can be converted back to its string representation with {\ttfamily addr.\+to\+String()}. Note that this method\+:
\begin{DoxyItemize}
\item does not return the original string used to create the object (in fact, there is no way of getting that string)
\item returns a compact representation (when it is applicable)
\end{DoxyItemize}

\hyperlink{class_a}{A} {\ttfamily match(range, bits)} method can be used to check if the address falls into a certain C\+I\+D\+R range. Note that an address can be (obviously) matched only against an address of the same type.

For example\+:


\begin{DoxyCode}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} addr = ipaddr.parse(\textcolor{stringliteral}{"2001:db8:1234::1"});
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} range = ipaddr.parse(\textcolor{stringliteral}{"2001:db8::"});

addr.match(range, 32); \textcolor{comment}{// => true}
\end{DoxyCode}


\hyperlink{class_a}{A} {\ttfamily range()} method returns one of predefined names for several special ranges defined by I\+P protocols. The exact names (and their respective C\+I\+D\+R ranges) can be looked up in the source\+: \href{https://github.com/whitequark/ipaddr.js/blob/master/src/ipaddr.coffee#L186}{\tt I\+Pv6 ranges} and \href{https://github.com/whitequark/ipaddr.js/blob/master/src/ipaddr.coffee#L71}{\tt I\+Pv4 ranges}. Some common ones include {\ttfamily \char`\"{}unicast\char`\"{}} (the default one) and {\ttfamily \char`\"{}reserved\char`\"{}}.

You can match against your own range list by using {\ttfamily ipaddr.\+subnet\+Match(address, range\+List, default\+Name)} method. It can work with both I\+Pv6 and I\+Pv4 addresses, and accepts a name-\/to-\/subnet map as the range list. For example\+:


\begin{DoxyCode}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} rangeList = \{
  documentationOnly: [ ipaddr.parse(\textcolor{stringliteral}{'2001:db8::'}), 32 ],
  tunnelProviders: [
    [ ipaddr.parse(\textcolor{stringliteral}{'2001:470::'}), 32 ], \textcolor{comment}{// he.net}
    [ ipaddr.parse(\textcolor{stringliteral}{'2001:5c0::'}), 32 ]  \textcolor{comment}{// freenet6}
  ]
\};
ipaddr.subnetMatch(ipaddr.parse(\textcolor{stringliteral}{'2001:470:8:66::1'}), rangeList, \textcolor{stringliteral}{'unknown'}); \textcolor{comment}{// => "he.net"}
\end{DoxyCode}


The addresses can be converted to their byte representation with {\ttfamily to\+Byte\+Array()}. (Actually, Java\+Script mostly does not know about byte buffers. They are emulated with arrays of numbers, each in range of 0..255.)


\begin{DoxyCode}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} bytes = ipaddr.parse(\textcolor{stringliteral}{'2a00:1450:8007::68'}).toByteArray(); \textcolor{comment}{// ipv6.google.com}
bytes \textcolor{comment}{// => [42, 0x00, 0x14, 0x50, 0x80, 0x07, 0x00, <zeroes...>, 0x00, 0x68 ]}
\end{DoxyCode}


The {\ttfamily ipaddr.\+I\+Pv4} and {\ttfamily ipaddr.\+I\+Pv6} objects have some methods defined, too. All of them have the same interface for both protocols, and are similar to global methods.

{\ttfamily ipaddr.\+I\+Pv\+X.\+is\+Valid(string)} can be used to check if the string is a valid address for particular protocol, and {\ttfamily ipaddr.\+I\+Pv\+X.\+parse(string)} is the error-\/throwing parser.

\paragraph*{I\+Pv6 properties}

Sometimes you will want to convert I\+Pv6 not to a compact string representation (with the {\ttfamily \+:\+:} substitution); the {\ttfamily to\+Normalized\+String()} method will return an address where all zeroes are explicit.

For example\+:


\begin{DoxyCode}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} addr = ipaddr.parse(\textcolor{stringliteral}{"2001:0db8::0001"});
addr.toString(); \textcolor{comment}{// => "2001:db8::1"}
addr.toNormalizedString(); \textcolor{comment}{// => "2001:db8:0:0:0:0:0:1"}
\end{DoxyCode}


The {\ttfamily is\+I\+Pv4\+Mapped\+Address()} method will return {\ttfamily true} if this address is an I\+Pv4-\/mapped one, and {\ttfamily to\+I\+Pv4\+Address()} will return an I\+Pv4 object address.

To access the underlying binary representation of the address, use {\ttfamily addr.\+parts}.


\begin{DoxyCode}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} addr = ipaddr.parse(\textcolor{stringliteral}{"2001:db8:10::1234:DEAD"});
addr.parts \textcolor{comment}{// => [0x2001, 0xdb8, 0x10, 0, 0, 0, 0x1234, 0xdead]}
\end{DoxyCode}


\paragraph*{I\+Pv4 properties}

{\ttfamily to\+I\+Pv4\+Mapped\+Address()} will return a corresponding I\+Pv4-\/mapped I\+Pv6 address.

To access the underlying representation of the address, use {\ttfamily addr.\+octets}.


\begin{DoxyCode}
\hyperlink{018__def_8c_a335628f2e9085305224b4f9cc6e95ed5}{var} addr = ipaddr.parse(\textcolor{stringliteral}{"192.168.1.1"});
addr.octets \textcolor{comment}{// => [192, 168, 1, 1]}
\end{DoxyCode}
 